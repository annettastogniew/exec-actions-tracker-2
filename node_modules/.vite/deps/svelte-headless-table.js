import "./chunk-AWKQUWFV.js";
import "./chunk-3SLAAXFE.js";
import {
  bind_this,
  check_target,
  component,
  derived,
  each,
  hmr,
  if_block,
  index,
  init,
  legacy_api,
  legacy_rest_props,
  onMount,
  prop,
  readable,
  setup_stores,
  slot,
  spread_props,
  store_get,
  validate_store,
  wrap_snippet,
  writable
} from "./chunk-QPRFPSXX.js";
import {
  append,
  comment,
  set_text,
  text
} from "./chunk-47S3OLHB.js";
import {
  FILENAME,
  HMR,
  add_owner_effect,
  derived_safe_equal,
  first_child,
  get,
  invalid_default_snippet,
  mark_module_end,
  mark_module_start,
  mutable_state,
  mutate,
  pop,
  push,
  set,
  strict_equals,
  template_effect
} from "./chunk-JL65Y4UA.js";
import "./chunk-X4XZK27Q.js";
import "./chunk-RIXFT5AQ.js";
import "./chunk-RVAV4ZRS.js";
import "./chunk-H3J74AKB.js";
import {
  __publicField
} from "./chunk-XSCQBFM2.js";

// node_modules/svelte-subscribe/dist/derivedKeys.js
var derivedKeys = (storeMap) => {
  const entries = Object.entries(storeMap);
  const keys = entries.map(([key]) => key);
  return derived(entries.map(([, store]) => store), ($stores) => {
    return Object.fromEntries($stores.map((store, idx) => [keys[idx], store]));
  });
};

// node_modules/svelte-subscribe/dist/Subscribe.svelte
mark_module_start();
Subscribe[FILENAME] = "node_modules/svelte-subscribe/dist/Subscribe.svelte";
function Subscribe($$anchor, $$props) {
  check_target(new.target);
  const $$sanitized_props = legacy_rest_props($$props, [
    "children",
    "$$slots",
    "$$events",
    "$$legacy"
  ]);
  const $$restProps = legacy_rest_props($$sanitized_props, []);
  push($$props, false, Subscribe);
  const [$$stores, $$cleanup] = setup_stores();
  const $values = () => (validate_store(values, "values"), store_get(values, "$values", $$stores));
  const values = derivedKeys($$restProps);
  init();
  var fragment = comment();
  var node = first_child(fragment);
  slot(node, $$props, "default", spread_props({}, $values), null);
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Subscribe = hmr(Subscribe, () => Subscribe[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Subscribe[HMR].source;
    set(Subscribe[HMR].source, module.default[HMR].original);
  });
}
var Subscribe_default = Subscribe;
mark_module_end(Subscribe);

// node_modules/svelte-render/dist/PropsRenderer.svelte
mark_module_start();
PropsRenderer[FILENAME] = "node_modules/svelte-render/dist/PropsRenderer.svelte";
function PropsRenderer($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, PropsRenderer);
  let instance = prop($$props, "instance", 28, () => void 0);
  let config = prop($$props, "config", 8);
  let props = prop($$props, "props", 24, () => void 0);
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      component(node_1, () => config().component, ($$anchor3, $$component) => {
        bind_this($$component($$anchor3, spread_props(() => props() ?? {}, { $$legacy: true })), ($$value) => instance($$value), () => instance());
      });
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_2 = comment();
      var node_2 = first_child(fragment_2);
      component(node_2, () => config().component, ($$anchor3, $$component) => {
        bind_this(
          $$component($$anchor3, spread_props(() => props() ?? {}, {
            children: wrap_snippet(PropsRenderer, ($$anchor4, $$slotProps) => {
              var fragment_3 = comment();
              var node_3 = first_child(fragment_3);
              each(node_3, 1, () => config().children, index, ($$anchor5, child) => {
                var fragment_4 = comment();
                var node_4 = first_child(fragment_4);
                Render_default(node_4, {
                  get of() {
                    return get(child);
                  }
                });
                append($$anchor5, fragment_4);
              });
              append($$anchor4, fragment_3);
            }),
            $$slots: { default: true },
            $$legacy: true
          })),
          ($$value) => instance($$value),
          () => instance()
        );
      });
      append($$anchor2, fragment_2);
    };
    if_block(node, ($$render) => {
      if (strict_equals(config().children.length, 0)) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  PropsRenderer = hmr(PropsRenderer, () => PropsRenderer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = PropsRenderer[HMR].source;
    set(PropsRenderer[HMR].source, module.default[HMR].original);
  });
}
var PropsRenderer_default = PropsRenderer;
mark_module_end(PropsRenderer);

// node_modules/svelte-render/dist/store.js
var isReadable = (value) => {
  return (value == null ? void 0 : value.subscribe) instanceof Function;
};
var Undefined = readable(void 0);

// node_modules/svelte-render/dist/ComponentRenderer.svelte
mark_module_start();
ComponentRenderer[FILENAME] = "node_modules/svelte-render/dist/ComponentRenderer.svelte";
function ComponentRenderer($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, ComponentRenderer);
  let config = prop($$props, "config", 8);
  let instance = mutable_state();
  onMount(function attachEventHandlers() {
    config().eventHandlers.forEach(([type, handler]) => {
      const callbacks = get(instance).$$.callbacks[type] ?? [];
      callbacks.push(handler);
      mutate(instance, get(instance).$$.callbacks[type] = callbacks);
    });
    return function detachEventHandlers() {
      config().eventHandlers.forEach(([type, handler]) => {
        const callbacks = get(instance).$$.callbacks[type];
        const idx = callbacks.findIndex((c) => strict_equals(c, handler));
        callbacks.splice(idx, 1);
      });
    };
  });
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var fragment_1 = comment();
      var node_1 = first_child(fragment_1);
      Subscribe_default(node_1, {
        get props() {
          return config().props;
        },
        children: invalid_default_snippet,
        $$slots: {
          default: ($$anchor3, $$slotProps) => {
            const props = derived_safe_equal(() => $$slotProps.props);
            var fragment_2 = comment();
            var node_2 = first_child(fragment_2);
            {
              add_owner_effect(() => get(instance), PropsRenderer_default);
              PropsRenderer_default(node_2, {
                get config() {
                  return config();
                },
                get props() {
                  return get(props);
                },
                get instance() {
                  return get(instance);
                },
                set instance($$value) {
                  set(instance, $$value);
                },
                $$legacy: true
              });
            }
            append($$anchor3, fragment_2);
          }
        }
      });
      append($$anchor2, fragment_1);
    };
    var alternate = ($$anchor2) => {
      var fragment_3 = comment();
      var node_3 = first_child(fragment_3);
      {
        add_owner_effect(() => get(instance), PropsRenderer_default);
        PropsRenderer_default(node_3, {
          get config() {
            return config();
          },
          get props() {
            return config().props;
          },
          get instance() {
            return get(instance);
          },
          set instance($$value) {
            set(instance, $$value);
          },
          $$legacy: true
        });
      }
      append($$anchor2, fragment_3);
    };
    if_block(node, ($$render) => {
      if (isReadable(config().props)) $$render(consequent);
      else $$render(alternate, false);
    });
  }
  append($$anchor, fragment);
  return pop({ ...legacy_api() });
}
if (import.meta.hot) {
  ComponentRenderer = hmr(ComponentRenderer, () => ComponentRenderer[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = ComponentRenderer[HMR].source;
    set(ComponentRenderer[HMR].source, module.default[HMR].original);
  });
}
var ComponentRenderer_default = ComponentRenderer;
mark_module_end(ComponentRenderer);

// node_modules/svelte-render/dist/Render.svelte
mark_module_start();
Render[FILENAME] = "node_modules/svelte-render/dist/Render.svelte";
function Render($$anchor, $$props) {
  check_target(new.target);
  push($$props, false, Render);
  const [$$stores, $$cleanup] = setup_stores();
  const $readableConfig = () => (validate_store(readableConfig, "readableConfig"), store_get(readableConfig, "$readableConfig", $$stores));
  let config = prop($$props, "of", 8);
  const readableConfig = isReadable(config()) ? config() : Undefined;
  init();
  var fragment = comment();
  var node = first_child(fragment);
  {
    var consequent = ($$anchor2) => {
      var text2 = text();
      template_effect(() => set_text(text2, $readableConfig()));
      append($$anchor2, text2);
    };
    var alternate_1 = ($$anchor2) => {
      var fragment_2 = comment();
      var node_1 = first_child(fragment_2);
      {
        var consequent_1 = ($$anchor3) => {
          var text_1 = text();
          template_effect(() => set_text(text_1, config()));
          append($$anchor3, text_1);
        };
        var alternate = ($$anchor3) => {
          var fragment_4 = comment();
          var node_2 = first_child(fragment_4);
          ComponentRenderer_default(node_2, {
            get config() {
              return config();
            }
          });
          append($$anchor3, fragment_4);
        };
        if_block(
          node_1,
          ($$render) => {
            if (strict_equals(typeof config(), "object", false)) $$render(consequent_1);
            else $$render(alternate, false);
          },
          true
        );
      }
      append($$anchor2, fragment_2);
    };
    if_block(node, ($$render) => {
      if (isReadable(config())) $$render(consequent);
      else $$render(alternate_1, false);
    });
  }
  append($$anchor, fragment);
  var $$pop = pop({ ...legacy_api() });
  $$cleanup();
  return $$pop;
}
if (import.meta.hot) {
  Render = hmr(Render, () => Render[HMR].source);
  import.meta.hot.accept((module) => {
    module.default[HMR].source = Render[HMR].source;
    set(Render[HMR].source, module.default[HMR].original);
  });
}
var Render_default = Render;
mark_module_end(Render);

// node_modules/svelte-render/dist/createRender.js
var ComponentRenderConfig = class {
  constructor(component2, props) {
    __publicField(this, "component");
    __publicField(this, "props");
    __publicField(this, "eventHandlers", []);
    __publicField(this, "children", []);
    this.component = component2;
    this.props = props;
  }
  on(type, handler) {
    this.eventHandlers.push([type, handler]);
    return this;
  }
  slot(...children) {
    this.children = children;
    return this;
  }
};
function createRender(component2, props) {
  return new ComponentRenderConfig(component2, props);
}

// node_modules/svelte-headless-table/dist/columns.js
var Column = class {
  constructor({ header, footer, height, plugins }) {
    __publicField(this, "header");
    __publicField(this, "footer");
    __publicField(this, "height");
    __publicField(this, "plugins");
    this.header = header;
    this.footer = footer;
    this.height = height;
    this.plugins = plugins;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isFlat() {
    return "__flat" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isData() {
    return "__data" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isDisplay() {
    return "__display" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isGroup() {
    return "__group" in this;
  }
};
var FlatColumn = class extends Column {
  constructor({ header, footer, plugins, id }) {
    super({ header, footer, plugins, height: 1 });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__flat", true);
    __publicField(this, "id");
    this.id = id ?? String(header);
  }
};
var DataColumn = class extends FlatColumn {
  constructor({ header, footer, plugins, cell, accessor, id }) {
    super({ header, footer, plugins, id: "Initialization not complete" });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__data", true);
    __publicField(this, "cell");
    __publicField(this, "accessorKey");
    __publicField(this, "accessorFn");
    this.cell = cell;
    if (accessor instanceof Function) {
      this.accessorFn = accessor;
    } else {
      this.accessorKey = accessor;
    }
    if (id === void 0 && this.accessorKey === void 0 && header === void 0) {
      throw new Error("A column id, string accessor, or header is required");
    }
    const accessorKeyId = typeof this.accessorKey === "string" ? this.accessorKey : null;
    this.id = id ?? accessorKeyId ?? String(header);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getValue(item) {
    if (this.accessorFn !== void 0) {
      return this.accessorFn(item);
    }
    if (this.accessorKey !== void 0) {
      return item[this.accessorKey];
    }
    return void 0;
  }
};
var DisplayColumn = class extends FlatColumn {
  constructor({ header, footer, plugins, id, cell, data }) {
    super({ header, footer, plugins, id });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__display", true);
    __publicField(this, "cell");
    __publicField(this, "data");
    this.cell = cell;
    this.data = data;
  }
};
var GroupColumn = class extends Column {
  constructor({ header, footer, columns, plugins }) {
    const height = Math.max(...columns.map((c) => c.height)) + 1;
    super({ header, footer, height, plugins });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__group", true);
    __publicField(this, "columns");
    __publicField(this, "ids");
    this.columns = columns;
    this.ids = getFlatColumnIds(columns);
  }
};
var getFlatColumnIds = (columns) => columns.flatMap((c) => c.isFlat() ? [c.id] : c.isGroup() ? c.ids : []);
var getFlatColumns = (columns) => {
  return columns.flatMap((c) => c.isFlat() ? [c] : c.isGroup() ? getFlatColumns(c.columns) : []);
};

// node_modules/svelte-headless-table/dist/utils/counter.js
var getCounter = (items) => {
  const result = /* @__PURE__ */ new Map();
  items.forEach((item) => {
    result.set(item, (result.get(item) ?? 0) + 1);
  });
  return result;
};

// node_modules/svelte-headless-table/dist/utils/array.js
var getDuplicates = (items) => {
  return Array.from(getCounter(items).entries()).filter(([, count]) => count !== 1).map(([key]) => key);
};

// node_modules/svelte-headless-table/dist/utils/css.js
var stringifyCss = (style) => {
  return Object.entries(style).map(([name, value]) => `${name}:${value}`).join(";");
};

// node_modules/svelte-headless-table/dist/utils/attributes.js
var mergeAttributes = (a, b) => {
  if (a.style === void 0 && b.style === void 0) {
    return { ...a, ...b };
  }
  return {
    ...a,
    ...b,
    style: {
      ...typeof a.style === "object" ? a.style : {},
      ...typeof b.style === "object" ? b.style : {}
    }
  };
};
var finalizeAttributes = (attrs) => {
  if (attrs.style === void 0 || typeof attrs.style !== "object") {
    return attrs;
  }
  return {
    ...attrs,
    style: stringifyCss(attrs.style)
  };
};

// node_modules/svelte-headless-table/dist/tableComponent.js
var TableComponent = class {
  constructor({ id }) {
    __publicField(this, "id");
    __publicField(this, "attrsForName", {});
    __publicField(this, "propsForName", {});
    __publicField(this, "state");
    this.id = id;
  }
  attrs() {
    return derived(Object.values(this.attrsForName), ($attrsArray) => {
      let $mergedAttrs = {};
      $attrsArray.forEach(($attrs) => {
        $mergedAttrs = mergeAttributes($mergedAttrs, $attrs);
      });
      return finalizeAttributes($mergedAttrs);
    });
  }
  props() {
    return derivedKeys(this.propsForName);
  }
  injectState(state) {
    this.state = state;
  }
  applyHook(pluginName, hook) {
    if (hook.props !== void 0) {
      this.propsForName[pluginName] = hook.props;
    }
    if (hook.attrs !== void 0) {
      this.attrsForName[pluginName] = hook.attrs;
    }
  }
};

// node_modules/svelte-headless-table/dist/bodyCells.js
var BodyCell = class extends TableComponent {
  constructor({ id, row }) {
    super({ id });
    __publicField(this, "row");
    this.row = row;
  }
  attrs() {
    return derived(super.attrs(), ($baseAttrs) => {
      return {
        ...$baseAttrs,
        role: "cell"
      };
    });
  }
  rowColId() {
    return `${this.row.id}:${this.column.id}`;
  }
  dataRowColId() {
    if (!this.row.isData()) {
      return void 0;
    }
    return `${this.row.dataId}:${this.column.id}`;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isData() {
    return "__data" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isDisplay() {
    return "__display" in this;
  }
};
var DataBodyCell = class _DataBodyCell extends BodyCell {
  constructor({ row, column, label, value }) {
    super({ id: column.id, row });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__data", true);
    __publicField(this, "column");
    __publicField(this, "label");
    __publicField(this, "value");
    this.column = column;
    this.label = label;
    this.value = value;
  }
  render() {
    if (this.label === void 0) {
      return `${this.value}`;
    }
    if (this.state === void 0) {
      throw new Error("Missing `state` reference");
    }
    return this.label(this, this.state);
  }
  clone() {
    const clonedCell = new _DataBodyCell({
      row: this.row,
      column: this.column,
      label: this.label,
      value: this.value
    });
    return clonedCell;
  }
};
var DisplayBodyCell = class _DisplayBodyCell extends BodyCell {
  constructor({ row, column, label }) {
    super({ id: column.id, row });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__display", true);
    __publicField(this, "column");
    __publicField(this, "label");
    this.column = column;
    this.label = label;
  }
  render() {
    if (this.state === void 0) {
      throw new Error("Missing `state` reference");
    }
    return this.label(this, this.state);
  }
  clone() {
    const clonedCell = new _DisplayBodyCell({
      row: this.row,
      column: this.column,
      label: this.label
    });
    return clonedCell;
  }
};

// node_modules/svelte-headless-table/dist/utils/filter.js
var nonUndefined = (value) => value !== void 0;

// node_modules/svelte-headless-table/dist/bodyRows.js
var BodyRow = class extends TableComponent {
  constructor({ id, cells, cellForId, depth = 0, parentRow }) {
    super({ id });
    __publicField(this, "cells");
    /**
     * Get the cell with a given column id.
     *
     * **This includes hidden cells.**
     */
    __publicField(this, "cellForId");
    __publicField(this, "depth");
    __publicField(this, "parentRow");
    __publicField(this, "subRows");
    this.cells = cells;
    this.cellForId = cellForId;
    this.depth = depth;
    this.parentRow = parentRow;
  }
  attrs() {
    return derived(super.attrs(), ($baseAttrs) => {
      return {
        ...$baseAttrs,
        role: "row"
      };
    });
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isData() {
    return "__data" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isDisplay() {
    return "__display" in this;
  }
};
var DataBodyRow = class _DataBodyRow extends BodyRow {
  constructor({ id, dataId, original, cells, cellForId, depth = 0, parentRow }) {
    super({ id, cells, cellForId, depth, parentRow });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__data", true);
    __publicField(this, "dataId");
    __publicField(this, "original");
    this.dataId = dataId;
    this.original = original;
  }
  clone({ includeCells = false, includeSubRows = false } = {}) {
    var _a;
    const clonedRow = new _DataBodyRow({
      id: this.id,
      dataId: this.dataId,
      cellForId: this.cellForId,
      cells: this.cells,
      original: this.original,
      depth: this.depth
    });
    if (includeCells) {
      const clonedCellsForId = Object.fromEntries(Object.entries(clonedRow.cellForId).map(([id, cell]) => {
        const clonedCell = cell.clone();
        clonedCell.row = clonedRow;
        return [id, clonedCell];
      }));
      const clonedCells = clonedRow.cells.map(({ id }) => clonedCellsForId[id]);
      clonedRow.cellForId = clonedCellsForId;
      clonedRow.cells = clonedCells;
    }
    if (includeSubRows) {
      const clonedSubRows = (_a = this.subRows) == null ? void 0 : _a.map((row) => row.clone({ includeCells, includeSubRows }));
      clonedRow.subRows = clonedSubRows;
    } else {
      clonedRow.subRows = this.subRows;
    }
    return clonedRow;
  }
};
var DisplayBodyRow = class _DisplayBodyRow extends BodyRow {
  constructor({ id, cells, cellForId, depth = 0, parentRow }) {
    super({ id, cells, cellForId, depth, parentRow });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__display", true);
  }
  clone({ includeCells = false, includeSubRows = false } = {}) {
    var _a;
    const clonedRow = new _DisplayBodyRow({
      id: this.id,
      cellForId: this.cellForId,
      cells: this.cells,
      depth: this.depth
    });
    clonedRow.subRows = this.subRows;
    if (includeCells) {
      const clonedCellsForId = Object.fromEntries(Object.entries(clonedRow.cellForId).map(([id, cell]) => {
        const clonedCell = cell.clone();
        clonedCell.row = clonedRow;
        return [id, clonedCell];
      }));
      const clonedCells = clonedRow.cells.map(({ id }) => clonedCellsForId[id]);
      clonedRow.cellForId = clonedCellsForId;
      clonedRow.cells = clonedCells;
    }
    if (includeSubRows) {
      const clonedSubRows = (_a = this.subRows) == null ? void 0 : _a.map((row) => row.clone({ includeCells, includeSubRows }));
      clonedRow.subRows = clonedSubRows;
    } else {
      clonedRow.subRows = this.subRows;
    }
    return clonedRow;
  }
};
var getBodyRows = (data, flatColumns, { rowDataId } = {}) => {
  const rows = data.map((item, idx) => {
    const id = idx.toString();
    return new DataBodyRow({
      id,
      dataId: rowDataId !== void 0 ? rowDataId(item, idx) : id,
      original: item,
      cells: [],
      cellForId: {}
    });
  });
  data.forEach((item, rowIdx) => {
    const cells = flatColumns.map((col) => {
      if (col.isData()) {
        const dataCol = col;
        const value = dataCol.getValue(item);
        return new DataBodyCell({
          row: rows[rowIdx],
          column: dataCol,
          label: col.cell,
          value
        });
      }
      if (col.isDisplay()) {
        const displayCol = col;
        return new DisplayBodyCell({
          row: rows[rowIdx],
          column: displayCol,
          label: col.cell
        });
      }
      throw new Error("Unrecognized `FlatColumn` implementation");
    });
    rows[rowIdx].cells = cells;
    flatColumns.forEach((c, colIdx) => {
      rows[rowIdx].cellForId[c.id] = cells[colIdx];
    });
  });
  return rows;
};
var getColumnedBodyRows = (rows, columnIdOrder) => {
  const columnedRows = rows.map((row) => {
    const clonedRow = row.clone();
    clonedRow.cells = [];
    clonedRow.cellForId = {};
    return clonedRow;
  });
  if (rows.length === 0 || columnIdOrder.length === 0)
    return rows;
  rows.forEach((row, rowIdx) => {
    const cells = row.cells.map((cell) => {
      const clonedCell = cell.clone();
      clonedCell.row = columnedRows[rowIdx];
      return clonedCell;
    });
    const visibleCells = columnIdOrder.map((cid) => {
      return cells.find((c) => c.id === cid);
    }).filter(nonUndefined);
    columnedRows[rowIdx].cells = visibleCells;
    cells.forEach((cell) => {
      columnedRows[rowIdx].cellForId[cell.id] = cell;
    });
  });
  return columnedRows;
};
var getSubRows = (subItems, parentRow, { rowDataId } = {}) => {
  const subRows = subItems.map((item, idx) => {
    const id = `${parentRow.id}>${idx}`;
    return new DataBodyRow({
      id,
      dataId: rowDataId !== void 0 ? rowDataId(item, idx) : id,
      original: item,
      cells: [],
      cellForId: {},
      depth: parentRow.depth + 1,
      parentRow
    });
  });
  subItems.forEach((item, rowIdx) => {
    const cellForId = Object.fromEntries(Object.values(parentRow.cellForId).map((cell) => {
      const { column } = cell;
      if (column.isData()) {
        const dataCol = column;
        const value = dataCol.getValue(item);
        return [
          column.id,
          new DataBodyCell({ row: subRows[rowIdx], column, label: column.cell, value })
        ];
      }
      if (column.isDisplay()) {
        return [
          column.id,
          new DisplayBodyCell({ row: subRows[rowIdx], column, label: column.cell })
        ];
      }
      throw new Error("Unrecognized `FlatColumn` implementation");
    }));
    subRows[rowIdx].cellForId = cellForId;
    const cells = parentRow.cells.map((cell) => {
      return cellForId[cell.id];
    });
    subRows[rowIdx].cells = cells;
  });
  return subRows;
};

// node_modules/svelte-headless-table/dist/constants.js
var NBSP = " ";

// node_modules/svelte-headless-table/dist/headerCells.js
var HeaderCell = class extends TableComponent {
  constructor({ id, label, colspan, colstart }) {
    super({ id });
    __publicField(this, "label");
    __publicField(this, "colspan");
    __publicField(this, "colstart");
    this.label = label;
    this.colspan = colspan;
    this.colstart = colstart;
  }
  render() {
    if (this.label instanceof Function) {
      if (this.state === void 0) {
        throw new Error("Missing `state` reference");
      }
      return this.label(this, this.state);
    }
    return this.label;
  }
  attrs() {
    return derived(super.attrs(), ($baseAttrs) => {
      return {
        ...$baseAttrs,
        role: "columnheader",
        colspan: this.colspan
      };
    });
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isFlat() {
    return "__flat" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isData() {
    return "__data" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isFlatDisplay() {
    return "__flat" in this && "__display" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isGroup() {
    return "__group" in this;
  }
  // TODO Workaround for https://github.com/vitejs/vite/issues/9528
  isGroupDisplay() {
    return "__group" in this && "__display" in this;
  }
};
var FlatHeaderCell = class _FlatHeaderCell extends HeaderCell {
  constructor({ id, label, colstart }) {
    super({ id, label, colspan: 1, colstart });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__flat", true);
  }
  clone() {
    return new _FlatHeaderCell({
      id: this.id,
      label: this.label,
      colstart: this.colstart
    });
  }
};
var DataHeaderCell = class _DataHeaderCell extends FlatHeaderCell {
  constructor({ id, label, accessorKey, accessorFn, colstart }) {
    super({ id, label, colstart });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__data", true);
    __publicField(this, "accessorKey");
    __publicField(this, "accessorFn");
    this.accessorKey = accessorKey;
    this.accessorFn = accessorFn;
  }
  clone() {
    return new _DataHeaderCell({
      id: this.id,
      label: this.label,
      accessorFn: this.accessorFn,
      accessorKey: this.accessorKey,
      colstart: this.colstart
    });
  }
};
var FlatDisplayHeaderCell = class _FlatDisplayHeaderCell extends FlatHeaderCell {
  constructor({ id, label = NBSP, colstart }) {
    super({ id, label, colstart });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__display", true);
  }
  clone() {
    return new _FlatDisplayHeaderCell({
      id: this.id,
      label: this.label,
      colstart: this.colstart
    });
  }
};
var GroupHeaderCell = class _GroupHeaderCell extends HeaderCell {
  constructor({ label, ids, allIds, colspan, colstart }) {
    super({ id: `[${ids.join(",")}]`, label, colspan, colstart });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__group", true);
    __publicField(this, "ids");
    __publicField(this, "allId");
    __publicField(this, "allIds");
    this.ids = ids;
    this.allId = `[${allIds.join(",")}]`;
    this.allIds = allIds;
  }
  setIds(ids) {
    this.ids = ids;
    this.id = `[${this.ids.join(",")}]`;
  }
  pushId(id) {
    this.ids = [...this.ids, id];
    this.id = `[${this.ids.join(",")}]`;
  }
  clone() {
    return new _GroupHeaderCell({
      label: this.label,
      ids: this.ids,
      allIds: this.allIds,
      colspan: this.colspan,
      colstart: this.colstart
    });
  }
};
var GroupDisplayHeaderCell = class _GroupDisplayHeaderCell extends GroupHeaderCell {
  constructor({ label = NBSP, ids, allIds, colspan = 1, colstart }) {
    super({ label, ids, allIds, colspan, colstart });
    // TODO Workaround for https://github.com/vitejs/vite/issues/9528
    __publicField(this, "__display", true);
  }
  clone() {
    return new _GroupDisplayHeaderCell({
      label: this.label,
      ids: this.ids,
      allIds: this.allIds,
      colspan: this.colspan,
      colstart: this.colstart
    });
  }
};

// node_modules/svelte-headless-table/dist/utils/math.js
var sum = (nums) => nums.reduce((a, b) => a + b, 0);

// node_modules/svelte-headless-table/dist/utils/matrix.js
var getNullMatrix = (width, height) => {
  const result = [];
  for (let i = 0; i < height; i++) {
    result.push(Array(width).fill(null));
  }
  return result;
};
var getTransposed = (matrix) => {
  const height = matrix.length;
  if (height === 0) {
    return matrix;
  }
  const width = matrix[0].length;
  const result = getNullMatrix(height, width);
  for (let i = 0; i < width; i++) {
    for (let j = 0; j < height; j++) {
      result[i][j] = matrix[j][i];
    }
  }
  return result;
};

// node_modules/svelte-headless-table/dist/headerRows.js
var HeaderRow = class _HeaderRow extends TableComponent {
  constructor({ id, cells }) {
    super({ id });
    __publicField(this, "cells");
    this.cells = cells;
  }
  attrs() {
    return derived(super.attrs(), ($baseAttrs) => {
      return {
        ...$baseAttrs,
        role: "row"
      };
    });
  }
  clone() {
    return new _HeaderRow({
      id: this.id,
      cells: this.cells
    });
  }
};
var getHeaderRows = (columns, flatColumnIds = []) => {
  const rowMatrix = getHeaderRowMatrix(columns);
  let columnMatrix = getTransposed(rowMatrix);
  columnMatrix = getOrderedColumnMatrix(columnMatrix, flatColumnIds);
  populateGroupHeaderCellIds(columnMatrix);
  return headerRowsForRowMatrix(getTransposed(columnMatrix));
};
var getHeaderRowMatrix = (columns) => {
  const maxColspan = sum(columns.map((c) => c.isGroup() ? c.ids.length : 1));
  const maxHeight = Math.max(...columns.map((c) => c.height));
  const rowMatrix = getNullMatrix(maxColspan, maxHeight);
  let cellOffset = 0;
  columns.forEach((c) => {
    const heightOffset = maxHeight - c.height;
    loadHeaderRowMatrix(rowMatrix, c, heightOffset, cellOffset);
    cellOffset += c.isGroup() ? c.ids.length : 1;
  });
  return rowMatrix.map((cells, rowIdx) => cells.map((cell, columnIdx) => {
    var _a;
    if (cell !== null)
      return cell;
    if (rowIdx === maxHeight - 1)
      return new FlatDisplayHeaderCell({ id: columnIdx.toString(), colstart: columnIdx });
    const flatId = ((_a = rowMatrix[maxHeight - 1][columnIdx]) == null ? void 0 : _a.id) ?? columnIdx.toString();
    return new GroupDisplayHeaderCell({ ids: [], allIds: [flatId], colstart: columnIdx });
  }));
};
var loadHeaderRowMatrix = (rowMatrix, column, rowOffset, cellOffset) => {
  if (column.isData()) {
    rowMatrix[rowMatrix.length - 1][cellOffset] = new DataHeaderCell({
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      label: column.header,
      accessorFn: column.accessorFn,
      accessorKey: column.accessorKey,
      id: column.id,
      colstart: cellOffset
    });
    return;
  }
  if (column.isDisplay()) {
    rowMatrix[rowMatrix.length - 1][cellOffset] = new FlatDisplayHeaderCell({
      id: column.id,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      label: column.header,
      colstart: cellOffset
    });
    return;
  }
  if (column.isGroup()) {
    for (let i = 0; i < column.ids.length; i++) {
      rowMatrix[rowOffset][cellOffset + i] = new GroupHeaderCell({
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        label: column.header,
        colspan: 1,
        allIds: column.ids,
        ids: [],
        colstart: cellOffset
      });
    }
    let childCellOffset = 0;
    column.columns.forEach((c) => {
      loadHeaderRowMatrix(rowMatrix, c, rowOffset + 1, cellOffset + childCellOffset);
      childCellOffset += c.isGroup() ? c.ids.length : 1;
    });
    return;
  }
};
var getOrderedColumnMatrix = (columnMatrix, flatColumnIds) => {
  if (flatColumnIds.length === 0) {
    return columnMatrix;
  }
  const orderedColumnMatrix = [];
  flatColumnIds.forEach((key, columnIdx) => {
    const nextColumn = columnMatrix.find((columnCells) => {
      const flatCell = columnCells[columnCells.length - 1];
      if (!flatCell.isFlat()) {
        throw new Error("The last element of each column must be a `FlatHeaderCell`");
      }
      return flatCell.id === key;
    });
    if (nextColumn !== void 0) {
      orderedColumnMatrix.push(nextColumn.map((column) => {
        const clonedColumn = column.clone();
        clonedColumn.colstart = columnIdx;
        return clonedColumn;
      }));
    }
  });
  return orderedColumnMatrix;
};
var populateGroupHeaderCellIds = (columnMatrix) => {
  columnMatrix.forEach((columnCells) => {
    const lastCell = columnCells[columnCells.length - 1];
    if (!lastCell.isFlat()) {
      throw new Error("The last element of each column must be a `FlatHeaderCell`");
    }
    columnCells.forEach((c) => {
      if (c.isGroup()) {
        c.pushId(lastCell.id);
      }
    });
  });
};
var headerRowsForRowMatrix = (rowMatrix) => {
  return rowMatrix.map((rowCells, rowIdx) => {
    return new HeaderRow({ id: rowIdx.toString(), cells: getMergedRow(rowCells) });
  });
};
var getMergedRow = (cells) => {
  if (cells.length === 0) {
    return cells;
  }
  const mergedCells = [];
  let startIdx = 0;
  let endIdx = 1;
  while (startIdx < cells.length) {
    const cell = cells[startIdx].clone();
    if (!cell.isGroup()) {
      mergedCells.push(cell);
      startIdx++;
      continue;
    }
    endIdx = startIdx + 1;
    const ids = [...cell.ids];
    while (endIdx < cells.length) {
      const nextCell = cells[endIdx];
      if (!nextCell.isGroup()) {
        break;
      }
      if (cell.allId !== nextCell.allId) {
        break;
      }
      ids.push(...nextCell.ids);
      endIdx++;
    }
    cell.setIds(ids);
    cell.colspan = endIdx - startIdx;
    mergedCells.push(cell);
    startIdx = endIdx;
  }
  return mergedCells;
};

// node_modules/svelte-headless-table/dist/createViewModel.js
var createViewModel = (table, columns, { rowDataId } = {}) => {
  const { data, plugins } = table;
  const $flatColumns = getFlatColumns(columns);
  const flatColumns = readable($flatColumns);
  const originalRows = derived([data, flatColumns], ([$data, $flatColumns2]) => {
    return getBodyRows($data, $flatColumns2, { rowDataId });
  });
  const _visibleColumns = writable([]);
  const _headerRows = writable();
  const _rows = writable([]);
  const _pageRows = writable([]);
  const _tableAttrs = writable({
    role: "table"
  });
  const _tableHeadAttrs = writable({});
  const _tableBodyAttrs = writable({
    role: "rowgroup"
  });
  const pluginInitTableState = {
    data,
    columns,
    flatColumns: $flatColumns,
    tableAttrs: _tableAttrs,
    tableHeadAttrs: _tableHeadAttrs,
    tableBodyAttrs: _tableBodyAttrs,
    visibleColumns: _visibleColumns,
    headerRows: _headerRows,
    originalRows,
    rows: _rows,
    pageRows: _pageRows
  };
  const pluginInstances = Object.fromEntries(Object.entries(plugins).map(([pluginName, plugin]) => {
    const columnOptions = Object.fromEntries($flatColumns.map((c) => {
      var _a;
      const option = (_a = c.plugins) == null ? void 0 : _a[pluginName];
      if (option === void 0)
        return void 0;
      return [c.id, option];
    }).filter(nonUndefined));
    return [
      pluginName,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      plugin({ pluginName, tableState: pluginInitTableState, columnOptions })
    ];
  }));
  const pluginStates = Object.fromEntries(Object.entries(pluginInstances).map(([key, pluginInstance]) => [
    key,
    pluginInstance.pluginState
  ]));
  const tableState = {
    data,
    columns,
    flatColumns: $flatColumns,
    tableAttrs: _tableAttrs,
    tableHeadAttrs: _tableHeadAttrs,
    tableBodyAttrs: _tableBodyAttrs,
    visibleColumns: _visibleColumns,
    headerRows: _headerRows,
    originalRows,
    rows: _rows,
    pageRows: _pageRows,
    pluginStates
  };
  const deriveTableAttrsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveTableAttrs).filter(nonUndefined);
  let tableAttrs = readable({
    role: "table"
  });
  deriveTableAttrsFns.forEach((fn) => {
    tableAttrs = fn(tableAttrs);
  });
  const finalizedTableAttrs = derived(tableAttrs, ($tableAttrs) => {
    const $finalizedAttrs = finalizeAttributes($tableAttrs);
    _tableAttrs.set($finalizedAttrs);
    return $finalizedAttrs;
  });
  const deriveTableHeadAttrsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveTableBodyAttrs).filter(nonUndefined);
  let tableHeadAttrs = readable({});
  deriveTableHeadAttrsFns.forEach((fn) => {
    tableHeadAttrs = fn(tableHeadAttrs);
  });
  const finalizedTableHeadAttrs = derived(tableHeadAttrs, ($tableHeadAttrs) => {
    const $finalizedAttrs = finalizeAttributes($tableHeadAttrs);
    _tableHeadAttrs.set($finalizedAttrs);
    return $finalizedAttrs;
  });
  const deriveTableBodyAttrsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveTableBodyAttrs).filter(nonUndefined);
  let tableBodyAttrs = readable({
    role: "rowgroup"
  });
  deriveTableBodyAttrsFns.forEach((fn) => {
    tableBodyAttrs = fn(tableBodyAttrs);
  });
  const finalizedTableBodyAttrs = derived(tableBodyAttrs, ($tableBodyAttrs) => {
    const $finalizedAttrs = finalizeAttributes($tableBodyAttrs);
    _tableBodyAttrs.set($finalizedAttrs);
    return $finalizedAttrs;
  });
  const deriveFlatColumnsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveFlatColumns).filter(nonUndefined);
  let visibleColumns = flatColumns;
  deriveFlatColumnsFns.forEach((fn) => {
    visibleColumns = fn(visibleColumns);
  });
  const injectedColumns = derived(visibleColumns, ($visibleColumns) => {
    _visibleColumns.set($visibleColumns);
    return $visibleColumns;
  });
  const columnedRows = derived([originalRows, injectedColumns], ([$originalRows, $injectedColumns]) => {
    return getColumnedBodyRows($originalRows, $injectedColumns.map((c) => c.id));
  });
  const deriveRowsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.deriveRows).filter(nonUndefined);
  let rows = columnedRows;
  deriveRowsFns.forEach((fn) => {
    rows = fn(rows);
  });
  const injectedRows = derived(rows, ($rows) => {
    $rows.forEach((row) => {
      row.injectState(tableState);
      row.cells.forEach((cell) => {
        cell.injectState(tableState);
      });
    });
    Object.entries(pluginInstances).forEach(([pluginName, pluginInstance]) => {
      $rows.forEach((row) => {
        var _a;
        if (((_a = pluginInstance.hooks) == null ? void 0 : _a["tbody.tr"]) !== void 0) {
          row.applyHook(pluginName, pluginInstance.hooks["tbody.tr"](row));
        }
        row.cells.forEach((cell) => {
          var _a2;
          if (((_a2 = pluginInstance.hooks) == null ? void 0 : _a2["tbody.tr.td"]) !== void 0) {
            cell.applyHook(pluginName, pluginInstance.hooks["tbody.tr.td"](cell));
          }
        });
      });
    });
    _rows.set($rows);
    return $rows;
  });
  const derivePageRowsFns = Object.values(pluginInstances).map((pluginInstance) => pluginInstance.derivePageRows).filter(nonUndefined);
  let pageRows = injectedRows;
  derivePageRowsFns.forEach((fn) => {
    pageRows = fn(pageRows);
  });
  const injectedPageRows = derived(pageRows, ($pageRows) => {
    $pageRows.forEach((row) => {
      row.injectState(tableState);
      row.cells.forEach((cell) => {
        cell.injectState(tableState);
      });
    });
    Object.entries(pluginInstances).forEach(([pluginName, pluginInstance]) => {
      $pageRows.forEach((row) => {
        var _a;
        if (((_a = pluginInstance.hooks) == null ? void 0 : _a["tbody.tr"]) !== void 0) {
          row.applyHook(pluginName, pluginInstance.hooks["tbody.tr"](row));
        }
        row.cells.forEach((cell) => {
          var _a2;
          if (((_a2 = pluginInstance.hooks) == null ? void 0 : _a2["tbody.tr.td"]) !== void 0) {
            cell.applyHook(pluginName, pluginInstance.hooks["tbody.tr.td"](cell));
          }
        });
      });
    });
    _pageRows.set($pageRows);
    return $pageRows;
  });
  const headerRows = derived(injectedColumns, ($injectedColumns) => {
    const $headerRows = getHeaderRows(columns, $injectedColumns.map((c) => c.id));
    $headerRows.forEach((row) => {
      row.injectState(tableState);
      row.cells.forEach((cell) => {
        cell.injectState(tableState);
      });
    });
    Object.entries(pluginInstances).forEach(([pluginName, pluginInstance]) => {
      $headerRows.forEach((row) => {
        var _a;
        if (((_a = pluginInstance.hooks) == null ? void 0 : _a["thead.tr"]) !== void 0) {
          row.applyHook(pluginName, pluginInstance.hooks["thead.tr"](row));
        }
        row.cells.forEach((cell) => {
          var _a2;
          if (((_a2 = pluginInstance.hooks) == null ? void 0 : _a2["thead.tr.th"]) !== void 0) {
            cell.applyHook(pluginName, pluginInstance.hooks["thead.tr.th"](cell));
          }
        });
      });
    });
    _headerRows.set($headerRows);
    return $headerRows;
  });
  return {
    tableAttrs: finalizedTableAttrs,
    tableHeadAttrs: finalizedTableHeadAttrs,
    tableBodyAttrs: finalizedTableBodyAttrs,
    visibleColumns: injectedColumns,
    flatColumns: $flatColumns,
    headerRows,
    originalRows,
    rows: injectedRows,
    pageRows: injectedPageRows,
    pluginStates
  };
};

// node_modules/svelte-headless-table/dist/createTable.js
var Table = class {
  constructor(data, plugins) {
    __publicField(this, "data");
    __publicField(this, "plugins");
    this.data = data;
    this.plugins = plugins;
  }
  createColumns(columns) {
    const ids = getFlatColumnIds(columns);
    const duplicateIds = getDuplicates(ids);
    if (duplicateIds.length !== 0) {
      throw new Error(`Duplicate column ids not allowed: "${duplicateIds.join('", "')}"`);
    }
    return columns;
  }
  column(def) {
    return new DataColumn(def);
  }
  group(def) {
    return new GroupColumn(def);
  }
  display(def) {
    return new DisplayColumn(def);
  }
  createViewModel(columns, options) {
    return createViewModel(this, columns, options);
  }
};
var createTable = (data, plugins = {}) => {
  return new Table(data, plugins);
};
export {
  BodyCell,
  BodyRow,
  Column,
  ComponentRenderConfig,
  DataBodyCell,
  DataBodyRow,
  DataColumn,
  DataHeaderCell,
  DisplayBodyCell,
  DisplayBodyRow,
  DisplayColumn,
  FlatColumn,
  FlatDisplayHeaderCell,
  FlatHeaderCell,
  GroupColumn,
  GroupDisplayHeaderCell,
  GroupHeaderCell,
  HeaderCell,
  HeaderRow,
  Render_default as Render,
  Subscribe_default as Subscribe,
  Table,
  createRender,
  createTable,
  getBodyRows,
  getColumnedBodyRows,
  getFlatColumnIds,
  getFlatColumns,
  getSubRows
};
//# sourceMappingURL=svelte-headless-table.js.map
